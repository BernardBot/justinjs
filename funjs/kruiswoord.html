<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas></canvas>
    <script>
        async function word_db(n) {
            let response = await fetch("https://raw.githubusercontent.com/OpenTaal/opentaal-wordlist/master/wordlist.txt");
            let text = await response.text();
            let words = text.split("\n");
            let shuffled = words.map(w => w.toLocaleLowerCase()).filter(x => x.length < 6).sort(() => Math.random() < 0.5);
            return shuffled.slice(0, n);
        }

        window.onload = async function () {
            wdb = await word_db(10000);

            canvas = document.querySelector("canvas");
            cw = CrossWord.from_string(
                "....."
            );
            cw.render(canvas, 50);
        };

        class CrossWord {
            static EMPTY = ".";
            static OFFSIDE = "_";

            constructor(width, height, board) {
                this.width = width;
                this.height = height;
                this.board = board;
            }

            static empty(width, height) {
                return new CrossWord(width, height, new Array(width * height).fill(CrossWord.EMPTY))
            }

            static from_string(string) {
                let rows = string.split("\n");

                let width = rows[0].length;
                let height = rows.length;

                let board = [];

                for (let i = 0; i < width; i++) {
                    for (let j = 0; j < height; j++) {
                        let k = i + j * width;
                        board[k] = rows[j][i];
                    }
                }

                return new CrossWord(width, height, board);
            }

            render(canvas, size) {
                canvas.width = this.width * size;
                canvas.height = this.height * size;

                let ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < this.width; i++) {
                    for (let j = 0; j < this.height; j++) {
                        let x = i * size;
                        let y = j * size;

                        let k = i + j * this.width;
                        let letter = this.board[k];

                        ctx.strokeRect(x, y, size, size);

                        if (letter == CrossWord.EMPTY) {
                            // do nothing...
                        } else if (letter == CrossWord.OFFSIDE) {
                            let d = size / 5;
                            ctx.fillRect(x + d, y + d, size - d * 2, size - d * 2);
                        } else {
                            // assume its a letter...
                            ctx.font = size / 1.5 + "px Arial";
                            ctx.fillText(letter.toUpperCase(), x + size / 4, y + size / 1.4);
                        }
                    }
                }
            }

            _puth(k, word) {
                for (let i = 0; i < word.length; i++) {
                    this.board[k + i] = word[i];
                }
            }

            _putv(k, word) {
                for (let i = 0; i < word.length; i++) {
                    this.board[k + i * this.width] = word[i];
                }
            }

            _geth(k, length) {
                let word = "";
                for (let i = 0; i < length; i++) {
                    word += this.board[k + i];
                }
                return word;
            }

            _getv(k, length) {
                let word = "";
                for (let i = 0; i < length; i++) {
                    word += this.board[k + i * this.width];
                }
                return word;
            }

            gen_moves() {
                let moves = [];

                // vertical moves
                for (let i = 0; i < this.width; i++) {
                    let word = "";
                    for (let j = 0; j < this.height; j++) {
                        let k = i + j * this.width;
                        let letter = this.board[k];

                        if (letter != CrossWord.OFFSIDE) {
                            word += letter;
                        }

                        if (letter == CrossWord.OFFSIDE || j == this.height - 1) {
                            if (word.length > 1) {
                                let h = k - word.length * this.width + this.width
                                let length = word.length;
                                let self = this;
                                moves.push({
                                    k: h,
                                    length: length,
                                    get: () => self._getv(h, length),
                                    put: word => self._putv(h, word),
                                });
                            }
                            word = "";
                        }
                    }
                }

                // horizontal moves
                for (let j = 0; j < this.height; j++) {
                    let word = "";
                    for (let i = 0; i < this.width; i++) {
                        let k = i + j * this.width;
                        let letter = this.board[k];

                        if (letter != CrossWord.OFFSIDE) {
                            word += letter;
                        }

                        if (letter == CrossWord.OFFSIDE || i == this.width - 1) {
                            if (word.length > 1) {
                                let h = k - word.length + 1;
                                let length = word.length;
                                let self = this;
                                moves.push({
                                    k: h,
                                    length: length,
                                    get: () => self._geth(h, length),
                                    put: word => self._puth(h, word),
                                });
                            }
                            word = "";
                        }
                    }
                }

                return moves;
            }

            solve(dictionary) {
                this.dictionary = dictionary;
                let moves = this.gen_moves();
                return this._solve(moves);
            }

            _solve(moves) {
                if (moves.length == 0) {
                    return true;
                }

                let move = moves[0];
                let board_word = move.get();
                let regex = new RegExp("^" + board_word + "$");
                // get the symbols at word position
                for (let dict_word of this.dictionary) {
                    // check if word matches regex of word on board
                    if (regex.test(dict_word)) {
                        move.put(dict_word);
                        // if so recur
                        if (this._solve(moves.slice(1))) {
                            return true;
                        }
                    }
                }
                // restore board
                move.put(board_word);
                // no word in the dictionary fit
                return false;
            }
        }
    </script>
</body>

</html>